[
["quantmod.html", "Capítulo 3 Quantmod 3.1 ¿Que es quantmod? 3.2 Obtención de Datos 3.3 Graficando con chartSeries 3.4 Graficando con ggplot2 3.5 Multiples Datos 3.6 Estadística Descriptiva 3.7 Ratio de Sharpe 3.8 Test de JarqueBera 3.9 Recursos del capítulo 3.10 Apéndice", " Capítulo 3 Quantmod IMPORTATE: Aún no está del todo listo el formato en pdf, por lo que recomiendo verlo online. El paquete quantmod para R esta diseñado para la asistencia quantitativa de los traders en el desarrollo de sus estrategias y modelos financieros. 3.1 ¿Que es quantmod? Un entorno rápido, donde los operadores cuantitativos pueden explorar y construir modelos de negociación rápida y limpiamente. A través de la función getSymbols podemos extraer datos financieros desde varias fuentes: Google Finance, Yahoo Finance, Federal Reserve Bank of St. Louis FRED (más de 11,000 series !!!) y Oanda. Incluso desde fuentes propias: MySQL , R (Rdata) y Comma Separated Value files (csv). No es el paquete definitivo dado que se complementa con otros, tales como: TTR, zoo y xts. En lo que respecta al análisis técnico son las más usadas en el mercado y usan todas las propiedades que hacen al lenguaje R útil para realizar análisis de datos1. 3.2 Obtención de Datos Para comenzar, como todo paquete en R se debe instalar # Instalación package install.packages(&quot;quantmod&quot;) Una vez que esté instalado, creamos nuestro script usando ctrl/cmd + shift + n y lo “llamamos” con # Cargamos &quot;quantmod&quot; library(&quot;quantmod&quot;) HINT: con ctrl + R en windows/Linux y cmd + R en MAC OS agregamos más rapido comentarios (sección) en Rstudio. quantmod provee una función para descargar datos desde fuentes externas. Esta función se llama getSymbols, para mayor información escribir en la linea de comandos ?getSymbols2. Por defecto, se crea un objeto en el workspace (Global Environment) con el nombre del ticker/nemotécnico seleccionado. Imaginemos por un momento que necesitamos analizar el S&amp;P 500 desde el 2010 hasta la fecha con periocidad diaria. Lo primero que debemos hacer es pensar desde que fuente vamos a descargar los datos, como es un índice accionario se recomienda usar yahoo finance, luego buscar el nemotécnico, en este caso es “^GSPC”. getSymbols(&quot;^GSPC&quot;, src = &quot;yahoo&quot;, from = &quot;2010-01-01&quot;, to = &quot;2010-07-30&quot;, periodicity = &quot;daily&quot;) ## [1] &quot;GSPC&quot; 3.2.1 ¿Qué hizo la función getSymbols? La función getSymbols se construye basicamente de cinco opciones3: El ticker/nemotécnico, eg. ^GSPC. src, que es la abreviación de “source”, eg. yahoo, FRED… from, es el inicio de la fecha a descargar, tener presente que se incluye la fecha en nuestros datos. to, es el final del periodo para los datos, este no se incluye. periodicity, es la periodicidad de los datos, eg. daily, monthly o yearly, solo algunos datos se ajustan a las tres periodicidades. En el ejemplo anterior se descargo desde yahoo los datos del S&amp;P 500 desde Enero del 2010 hasta el viernes 27 de Julio del 2018 con periodicidad diaria, construyendo un objeto en formato xts cuyo nombre es GSPC. 3.3 Graficando con chartSeries Aún no introducimos la librería ggplot2, sin embargo, quantmod también nos permite graficar. 3.3.1 chartSeries Para graficar basta con escribir el nombre del objeto con clase (class) xts, en nuestro caso es GSPC que representa al Standard and Poor 500. Si escribimos TA = NULL, charSeries no mostrará el volume4 chartSeries(GSPC, TA=NULL) Figure 3.1: Gráfico con chartSeries con TA = NULL chartSeries(GSPC, TA=NULL) Figure 3.2: Gráfico con chartSeries sin TA = NULL Pero cuando las series son muy largas, podemos ver tendencias pero dificulta ver cambios importantes a nivel de análisis técnico. chartSeries(GSPC, subset = &quot;last 3 months&quot;) Figure 3.3: Los últimos 3 meses de GSPC Con el código anterior nos enfocamos solo en los tres meses anteriores. 3.4 Graficando con ggplot2 Si bien chartSeries es una alternativa a plot o plotly, este no nos permite realizar gráficos que se adapten a nuestras necesidades. ¿Qué pasa si queremos graficar retornos o retornos acumulados? la opción por exelencia es ggplot2. 3.4.1 Breve introducción a ggplot2 Todo ggplot2 plot tiene tres componentes: Datos Un conjunto de aesthetic mappings entre variables y propiedades de visualización. Al menos una layer que describe la observación, son usualmente creadas con la función geom_* library(ggplot2) A continuación usaremos la base que viene pre cargada con R cuando lo instalamos, que es cars5 ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() Figure 3.4: Ejemplo 1 usando ggplot2 Esto produce el scatterplot definido como: Datos: mpg Aesthetic mapping: tamaño del motor en la posición x, gasolina en la posición y. Layer: puntos. 3.4.2 Color, tamaño, forma y otros atributos del aesthetic Se debe usar otro aesthetics como colour, shape y size (ggplot acepta los nombres americanos como británicos) ggplot(mpg, aes(displ, cty, colour = class)) + geom_point() Figure 3.5: Ejemplo 2 usando ggplot2 Como se puede ver, se creo una guía con los valores, leyenda, así podemos “leer” el gráfico. Si se quiere aesthetic para valores fijos, sin scaling: ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = &quot;blue&quot;)) Figure 3.6: Ejemplo 3 usando ggplot2 ggplot(mpg, aes(displ, hwy)) + geom_point(colour = &quot;blue&quot;) Figure 3.7: Ejemplo 3 usando ggplot2 Ejercicios: aes(displ, hwy, colour = class) aes(displ, hwy, shape = drv) aes(displ, hwy, size = cyl) Se recomienda usar colour y shape con variables categóricas. Mientras que size funciona bien con variables continuas. 3.4.3 S&amp;P 500 con ggplot2 gspc &lt;- as.data.frame(GSPC) g1 &lt;- ggplot(gspc) + geom_line(mapping = aes(index(gspc),GSPC.Adjusted)) g1 &lt;- g1 + labs(title = &quot;S&amp;P 500&quot;, subtitle = &quot;Desde Enero 2010 a 2018&quot;) + xlab(&quot;Fecha&quot;) + ylab(&quot;&quot;) g1 &lt;- g1 + theme_bw() g1 Figure 3.8: Standard and Poor 500 usando ggplot2 3.5 Multiples Datos A continuación trabajaremos con las acciones de Oracle, Nvidia, IBM y AMD, comenzamos con crear un objeto con los nombres de los tickers tickers &lt;- c(&quot;ORCL&quot;,&quot;AMD&quot;,&quot;IBM&quot;,&quot;NVDA&quot;) descargamos los datos con las características requeridas, que son las mismas que usamos anteriormente con S&amp;P 500 getSymbols(tickers, src = &quot;yahoo&quot;, from = &quot;2010-01-01&quot;, to = &quot;2018-07-30&quot;, periodicity = &quot;daily&quot;) ## [1] &quot;ORCL&quot; &quot;AMD&quot; &quot;IBM&quot; &quot;NVDA&quot; Acá deben tener mucha atención: list &lt;- lapply(tickers, function(x) Cl(get(x))) precio.cierre &lt;- do.call(merge,list) 3.5.1 Retornos La formula para calcular (log) retornos es \\[ r_t = log(1 + R_t) = log(\\frac{P_t}{P_{t-1}}) = p_t - p_{t-1} \\] donde \\(p_t = log(P_t)\\) es llamado “log price”. Ahora pasamos a construir el retorno. retornos &lt;- data.frame(apply(precio.cierre, 2, function(x) Delt(x, type = &quot;log&quot;)), fecha = index(precio.cierre)) %&gt;% rename(orcl = ORCL.Close, amd = AMD.Close, ibm = IBM.Close, nvda = NVDA.Close) %&gt;% na.omit() 3.5.2 Retornos Acumulados Si graficamos los retornos no será muy descriptivo, una forma es trabajar con su acumulado. Con la misma lógica usamos la función cumsum(). acumulados &lt;- data.frame(apply(retornos[1:4], 2, function(x) cumsum(x)), fecha = index(precio.cierre[-1])) 3.5.2.1 Gráfico retornos acumulados library(&quot;reshape2&quot;) reshape &lt;- melt(acumulados, id.vars = &quot;fecha&quot;) g2 &lt;- ggplot(reshape) + geom_line(mapping = aes(fecha,value, color = variable)) g2 &lt;- g2 + labs(title = &quot;Retornos Acumulados&quot;, subtitle = &quot;Oracle, AMD, IBM y Nvidia&quot;) g2 &lt;- g2 + theme_bw() + xlab(&quot;Fecha&quot;) + ylab(&quot;Retornos Acumulados&quot;) g2 &lt;- g2 + scale_color_manual(&quot;Tickers&quot;, values = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;orange&quot;)) g2 &lt;- g2 + theme(legend.position = &quot;bottom&quot;) g2 Figure 3.9: Retornos Acumulados de los tickers 3.6 Estadística Descriptiva Existe muchas formas de obtener la estadística descriptiva en R, un librería es fBasics, la que a su vez contiene test de normalidad. library(&quot;fBasics&quot;) summary &lt;- basicStats(retornos[1:4])[c(&quot;Mean&quot;, &quot;Stdev&quot;, &quot;Median&quot;, &quot;Minimum&quot;, &quot;Variance&quot;, &quot;Maximum&quot;, &quot;nobs&quot;,&quot;Skewness&quot;,&quot;Kurtosis&quot;),] 3.7 Ratio de Sharpe EL ratio de Sharpe es una medida de desempeño para portafolios, el que se define como \\[ SR = \\frac{E(R_i) - r_f}{\\sigma_i} \\] Donde \\(E(R_i) = \\mu_i\\) es el retorno del portafolio \\(i\\), \\(r_f\\) la tasa libre de riesgo y \\(\\sigma_i\\) la desviaciòn estandar del portafolio \\(i\\). Si asumimos como ejercicio que no diversificamos y “construimos” cuatro portafolios con el 100% es invertido en cada uno de los activos. Para realizar el cálculo del ratio de Sharpe (SR) para Oracle SR_orcl &lt;- (mean(retornos$orcl) - 0.0000 )/sd(retornos$orcl) con mean(retornos$orcl) vamos a obtener el promedio de la primera columna del objeto retornos que es Oracle (en el data.frame la columna se llama orcl, si tuviese otro nombre como por ejemplo perrito, entonces hubiese sido mean(retornos$perrito)), si quisieramos AMD debería ser amd y asì sucesivamente. El 0.0000 sería la tasa libre de riesgo que la asumimos mensual y sd(retornos[1]) nos calcula la desviación estandar. Dado que poseemos 4 activos con sus respectivos retornos, deberiamos construir cuatro objetos que partan con SR. 3.8 Test de JarqueBera El test de jarque-bera usa los coeficientes de la skewness y kurtosis de la muestra y se usa para testar normalidad. Otros test comunes son el de Anderson–Darling, Cramér–von Mises, y Kolmogorov–Smirnov. En resumen compara que la skewness sea 0 y la kurtosis sea 3 bajo normalidad. \\[ JB = n{\\widehat{Sk}^2 /6 + (\\widehat{KUr} - 3)^2 /24} \\] El test se encuentra en varias librerías, una de ellas es fBasics que deberíamos tener instalada y cargada. Para obtener los resultados del test para Oracle jarqueberaTest(retornos$orcl) Para los demàs activos hay que solo cambiar por el nombre de la columna correspondiente. 3.9 Recursos del capítulo Presentación 3.10 Apéndice Existe más de una forma de calcular los retornos y retornos acumulados. A continuación cargaremos una base que contiene los precios al cierre desde Enero del 2013 hasta Diciembre del 2018 con periodicidad mensual de las siguientes empresas tecnológicas: Facebook (FB) Amazon (AMZN) Apple (AAPL) Netflix (NFLX) Google (GOOG) Ahora en adelante FAANG. La base de datos se encuentran almacenada en Dropbox en el siguiente enlace https://www.dropbox.com/s/tjqvs9w16al1jl2/FAANG.csv?dl=1 Como tiene una extensión csv, utilizamos: FAANG &lt;- read_csv(&quot;https://www.dropbox.com/s/tjqvs9w16al1jl2/FAANG.csv?dl=1&quot;) De esta manera podemos descargarla inmediatamente desde dropbox a nuestra sesión en RStudio. La base de FAANG contiene las siguientes observaciones. 3.10.1 Retorno y retorno acumulado La forma en que calcularemos el retorno logarítmico es siguiendo la formula presentado durante el capítulo: \\[ r_t = log(1 + R_t) = log(\\frac{P_t}{P_{t-1}}) = p_t - p_{t-1} \\] Como tenemos la fecha (date) y el resto de las columnas con los precios, una forma es crear una objeto con tres columnas, fecha (date), symbol (tickers) y precios (prices). Lo anterior se logra utilizando gather(symbol, prices, -date), luego agrupamos por symbol por medio de group_by(symbol) y creamos el retorno mutate(returns = log(prices/lag(prices))). Como tendremos NA usamos filter(!is.na(returns)), finalmente eliminamos la columna price y extendemos el objeto de tal forma de tener la fecha (date) y las columnas restantes sea el retorno correspondiente a cada tickers (symbol), spread(symbol, returns). Todo lo anterior se resume en el siguiente código: # retornos FAANG_returns &lt;- FAANG %&gt;% gather(symbol, prices, -date) %&gt;% group_by(symbol) %&gt;% mutate(returns = log(prices/lag(prices))) %&gt;% filter(!is.na(returns)) %&gt;% select(-prices) %&gt;% spread(symbol, returns) La lógica para los retornos acumulados es el mismo, pero ahora no debemos trabajar con el objeto FAANG, sino con FAANG_returns. FAANG_acum &lt;- FAANG_returns %&gt;% gather(symbol, returns, -date) %&gt;% group_by(symbol) %&gt;% mutate(returns_acum = cumsum(returns)) %&gt;% select(-returns) %&gt;% spread(symbol, returns_acum) 3.10.2 Graficar retorno acumulado FAANG_acum %&gt;% gather(symbol, returns_acum, -date) %&gt;% ggplot(aes(y = returns_acum, x = date, color = symbol)) + geom_line(size = 1.5) + labs(title = &quot;Retornos Acumulados&quot;, subtitle = &quot;FAANG&quot;, color = &quot;&quot;) + theme_bw() + theme(legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;) Proximamente incluire el tidyquant↩ No solo funcióna con getSymbols, si no que con todas las funciones de distintas librerias, basta con ante poner ? y luego el nombre la función↩ Por el momento solo trabajaremos con estas opciones, exiten más.↩ TA proviene de Technical Analysis↩ Esta base es muy común en los software estadísticos y presenta datos de autos.↩ "]
]
