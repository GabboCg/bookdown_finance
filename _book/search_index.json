[
["index.html", "Introducción a las finanzas quantitativas Aplicaciones &amp; ejemplos usando R Prefacio", " Introducción a las finanzas quantitativas Aplicaciones &amp; ejemplos usando R Gabriel Cabrera G. 2019-04-14 Prefacio Este es un apunte en proceso pensado en el curso de Finanzas I de Ingeniería Comercial de la Universidad de Chile, las aplicaciones en R son pensados con un enfoque pedagógico y cualquier comentario o sugerencias son bienvenidas. La información de la sesión de R cuando se compila este apunte es la siguiente: sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Ubuntu 18.04.2 LTS ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1 ## ## locale: ## [1] LC_CTYPE=es_CL.UTF-8 ## [2] LC_NUMERIC=C ## [3] LC_TIME=es_CL.UTF-8 ## [4] LC_COLLATE=es_CL.UTF-8 ## [5] LC_MONETARY=es_CL.UTF-8 ## [6] LC_MESSAGES=es_CL.UTF-8 ## [7] LC_PAPER=es_CL.UTF-8 ## [8] LC_NAME=C ## [9] LC_ADDRESS=C ## [10] LC_TELEPHONE=C ## [11] LC_MEASUREMENT=es_CL.UTF-8 ## [12] LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets ## [6] methods base ## ## loaded via a namespace (and not attached): ## [1] Rcpp_1.0.1 rstudioapi_0.10 knitr_1.22 ## [4] magrittr_1.5 tidyselect_0.2.5 munsell_0.5.0 ## [7] colorspace_1.4-1 R6_2.4.0 rlang_0.3.4 ## [10] stringr_1.4.0 plyr_1.8.4 dplyr_0.8.0.1 ## [13] tools_3.4.4 grid_3.4.4 gtable_0.3.0 ## [16] xfun_0.6 htmltools_0.3.6 yaml_2.2.0 ## [19] lazyeval_0.2.2 assertthat_0.2.1 digest_0.6.18 ## [22] tibble_2.1.1 bookdown_0.9 crayon_1.3.4 ## [25] purrr_0.3.2 ggplot2_3.1.1 glue_1.3.1 ## [28] evaluate_0.13 rmarkdown_1.12 stringi_1.4.3 ## [31] compiler_3.4.4 pillar_1.3.1 scales_1.0.0 ## [34] pkgconfig_2.0.2 "],
["sobre-el-autor.html", "Sobre el Autor", " Sobre el Autor Aún no hay mucho que decir, pero te invito a visitar mi página web donde la mayoría del tiempo estoy publicando post sobre programación y/o data science con aplicaciones a las finanzas y al mundo real. Me agradan las citas… “It is a capital mistake to theorize before one has data. Insensibly one begins to twist facts to suit theories, instead of theories to suit facts.” Sir Arthur Conan Doyle "],
["intro.html", "Capítulo 1 Introducción 1.1 R 1.2 RStudio 1.3 Scripts 1.4 Proyectos 1.5 Packages 1.6 Ejemplo", " Capítulo 1 Introducción Antes de comenzar tú viaje a través del lenguaje de programación R, necesitaras cuatro “herramientas” básicas para trabajar con este apunte, R (lenguaje), Rstudio(IDE1), una megalibrería que contiene R packages llamada tidyverse y librerías extras para trabajar en finanzas2. 1.1 R 1.1.1 Un poco de historia R es un lenguaje de programación creado por Ross Ihaka y Robert Gentleman del departamento de estadística de la universidad de Auckland en 1992 (Nueva Zelanda), teniendo su versión estable el 29 de Febrero del 2000. 1.1.2 Los primeros pasos El primer paso es descargar R, para esto debes ir a CRAN3, comprehensive R archive network. CRAN esta compuesto por un conjunto de mirror servers distribuidos alrededor del mundo y se usa para compartir los R packages. Como recomendación no elegir un mirror lejano a tú posición geográfica, por ende, usa https://cloud.r-project.org que los seleccionará automáticamente. Como aún no instalas RStudio solo tendras el lenguaje, que puede ser ejecutado desde el command Shell o prompt, no obstante, esto es ineficiente desde el punto de vista que no tendrenmos todas las opciones que Rstudio nos entrega. Figure 1.1: logo de R Si trabajas sin IDE veras algo como en la Figura 1.2. Figure 1.2: R desde la terminal Las versiones de R cambian una vez al año, y de 2 a 3 veces con cambios pequeños, por eso es una buena idea que mantengas actualizada tu versión. 1.2 RStudio ¿Qué es una IDE? IDE es el acrónimo de Integrated Development Environment (Entorno de Desarrollo Integrado). Esto quiere decir que RStudio es una aplicación que nos entrega herramientas para hacer más fácil el desarrollo de proyectos usando R y sobre todo cuando estemos trabajando con datos. Para descargar e instalar Rstudio debes ir a http//www.rstudio.com/download y seleccionar RStudio Desktop Open Source License (gratuita) , cuando exista una actualización Rstudio te avisará. Si quedó todo bien instalado, cuando abras Rstudio deberías ver algo así: Figure 1.3: Rstudio IMPORTANTE: Si te aparece algún error durante este proceso, lo más probabable es que sea por alguna configuración de tu sistema operativo. En ese caso, la mejor manera de buscar una solución es copiar el error que arroja R, pegarlo en tu motor de búsqueda favorito y ver cómo alguien que se enfrentó a eso antes lo resolvió. 1.2.1 Partes de RStudio ¿Para qué sirven estos paneles? Comentemos primero el panel de abajo a la derecha. Si te fijas, el panel tiene varias ventanas: Files muestra el directorio (la carpeta) en la que te encuentras actualmente. En mi caso, no hay nada ahí porque por defecto RStudio me muestra el Escritorio (Desktop) y no tengo nada en él. Es posible que a ti te muestre otra carpeta (por ejemplo, Documentos). Plots es el lugar donde aparecerán los gráficos que vayas creando. No hemos hecho ninguno por ahora, así que este panel también está vacío. Packages muestra la lista de paquetes que tienes instalados en tu computador. Si recorres el panel verás que algunos tiene una marca al lado izquierdo. Eso quiere decir que el paquete está activo en ese momento (ya veremos cómo hacer eso). Solo los paquetes vinculados a R base se activan al abrir RStudio. Help, como su nombre lo indica, es la pestaña en la que podemos encontrar ayuda. Si buscamos el nombre de un paquete o de una función, RStudio nos remitirá a la documentación asociada. Viewer es el panel para ver contenido web generado por algún paquete de R (gráficos para la web o aplicaciones interactivas). Por el momento no lo utilizaremos. El panel de arriba a la derecha, por su parte, contiene el historial de funciones que hemos ejecutado (History), la opción para generar conexiones a bases de datos externas (Connections) y el Environment. Este último panel es muy importante y entender lo que nos muestra es fundamental para comprender cómo funciona R. 1.3 Scripts El script podemos decir que es un cuarto panel4, en donde escribiras tus códigos que queremos que ejecute R, para crear un script debes: ir a file &gt; New File &gt; R Script Otra forma es un atajo de teclado, control + shift + n (Linux/Windows) y comando + shift + n (Mac OS). O bien ir a la barra superior de la ventana y seleccionar el tipo de archivo a trabajar. 1.4 Proyectos Una de las ventajas de RStudio es que permite crear “proyectos”. Un projecto es un espacio o contexto de trabajo asociado a una carpeta en particular, en la que se guardan nuestro(s) script(s), archivos de datos, etc. Cuando creamos un proyecto en RStudio, se crea un tipo especial de archivo (.Rproj) que lo que hace es vincular todo lo que se encuentra dentro de esa carpeta. ###¿Por qué esto es útil? Si parte de nuestro script, por ejemplo, implica abrir un archivo que está en la carpeta de nuestro proyecto, no necesito indicar en mi código toda la ruta del archivo: lo que hará RStudio será buscarlo en el entorno/carpeta del proyecto. Si movemos la carpeta a otro lugar de nuestro computador o la compartimos con otra persona, nuestro código seguirá funcionando, ya que el archivo .Rproj mantendrá todo unido. Si no creara un proyecto, tendría que indicar al inicio de mi script cuál es la ruta de la carpeta que ocuparé como espacio de trabajo. El problema de esa opción es que si muevo la carpeta o le cambio el nombre, tendría que volver a escribir la ruta para que todo funcione. Al crear un proyecto eso deja de ser una preocupación. ###¿Cómo crear un projecto? Puedes hacerlo desde el menú File &gt; New Proyect. Lo primero que nos pregunta es si queremos crearlo en una carpeta nueva o en una ya existente. Elegiremos esta vez una carpeta nueva, así que seleccionaremos New Directory. La siguiente pregunta es qué tipo de proyecto queremos crear. En esta ocasión, elegiremos la primera: New Project. Finalmente, le damos un nombre al proyecto y decidimos en qué parte de nuestro computador queremos que viva la carpeta que lo contiene. Luego de apretar Create Project, RStudio se reinicia y se producen algunos cambios. El panel Files (abajo a la derecha) ahora nos muestra la carpeta de nuestro proyecto y el único archivo que hay en ella por ahora. Ese es el archivo mágico que mantiene unido todo lo que hay dentro de la carpeta. Cuando queramos volver a trabajar en nuestro proyecto, solo tenemos que abrir ese archivo. IMPORTANTE: RStudio ejecuta sesiones independientes de R para cada proyecto. Es decir, si tuvieras otro proyecto abierto te aparecería otro ícono, con su respectivo nombre. Esto nos permite trabajar en dos proyectos en paralelo sin que se nos mezclen los objetos del entorno, el código, los archivos, etc. Cada cosa en su lugar. 1.5 Packages Cuando instalamos R por primera vez en nuestro computador, lo que estamos instalando es lo que se conoce como “R Base”, es decir, los elementos centrales del lenguaje de programación. Una de las ventajas de R es que se trata de un lenguaje extensible: la propia comunidad de usuarios puede desarrollar nuevas posibilidades para utilizarlo. La manera de compartir estos nuevos desarrollos es a través de “paquetes”, que incluyen, entre otras cosas, código y datos. Una analogía que se suele utilizar para explicar esto es que R Base es un teléfono celular tal como viene de fábrica y los paquetes las apps que descargamos para que tenga más funcionalidades. Para usar las librerias (“packages”) debemos usar el siguiente código: # instala el package install.packages(&quot;acá va el package&quot;) # lo llama library(&quot;acá va el package&quot;) 1.5.1 tidyverse tidyverse es un “megapaquete” que incluye otros paquetes en su interior. Todos los paquetes que conforman “el Tidyverse” comparten la misma visión sobre el trabajo con datos y la escritura de código. Viene a formar parte de la nueva forma de programar en R, cuyo enfoque es netamente en realizar Data Science. Algunas librerias relevantes son: ggplot2: Esta librería te permite realizar graficos avanzados. dplyr: Su objetivo es la manipulación de datos (filtrar, seleccionar, generar, renombrar,etc). magrittr: Contiene la denominada pipe ( %&gt;% ), se explicará más adelante purrr: Para realizar iteraciones. readr: Para cargar datos en csv, lo importante que los transforma en tibble. Para instalarlo basta escribir: # instala el package install.packages(&quot;tidyverse&quot;) # lo llama library(&quot;tidyverse&quot;) Si te vas a la pestaña de Packages verás que estan seleccionadas aquellas librerias que se encuentran en el tidyverse. 1.6 Ejemplo En este ejemplo vamos a trabajar con gapminder, un paquete que contiene una parte de los datos de Gapminder, una base de datos que incluye información mundial sobre población, expectativa de vida, PIB per cápita y otros. Su autor, Hans Rosling, ha hecho varias charlas TED que vale la pena mirar. Instalamos la librería # instala el package install.packages(&quot;gapminder&quot;) Cargamos tanto gapminder como tidyverse # lo llama library(&quot;gapminder&quot;) library(&quot;tidyverse&quot;) Calculamos el promedio de la expectativa de vida para los continentes en el 2007: world.data &lt;- gapminder mean.lifeExp &lt;- world.data %&gt;% filter(year == 2007) %&gt;% group_by(continent) %&gt;% summarize(mean(lifeExp)) mean.lifeExp Lo visualizamos Construimos la base de datos y graficamos la evolución de la expectativa de vida para los países de America del Sur desde 1952 a 2007. world.data &lt;- world.data %&gt;% filter(country %in% c(&quot;Argentina&quot;, &quot;Bolivia&quot;, &quot;Brazil&quot;, &quot;Chile&quot;, &quot;Colombia&quot;, &quot;Ecuador&quot;, &quot;Paraguay&quot;, &quot;Peru&quot;, &quot;Uruguay&quot;, &quot;Venezuela&quot;)) g1 &lt;- ggplot(world.data) + geom_line(mapping = aes(year,lifeExp, colour= country), size = 1.2) g1 &lt;- g1 + theme_bw() + labs(title = &quot;Expectativa de vida para America del Sur&quot;, subtitle = &quot;Desde 1952 a 2007&quot;, colour = &quot;&quot;) g1 &lt;- g1 + xlab(&quot;Años&quot;) + ylab(&quot;Expectativa de vida&quot;) g1 &lt;- g1 + theme(legend.position=&quot;bottom&quot;) g1 Finalmente lo guardamos. ggsave(&quot;Grafico.png&quot;) Integrated Development Environment↩ Estas librerías las iremos cargando/utilizando a medida que avancemos en los capítulos↩ Existe otra distribución de R por parte del area de open source de Microsoft , la ventaja de MRAN es que si bien funciona con CRAN, su objetivo va más orientado a computación en paralelo (paralleling computing)↩ El tercer panel es la consola↩ "],
["quantmod.html", "Capítulo 2 Quantmod 2.1 ¿Que es quantmod? 2.2 Obtención de Datos 2.3 Graficando con chartSeries 2.4 Graficando con ggplot2 2.5 Multiples Datos 2.6 Estadística Descriptiva 2.7 Ratio de Sharpe 2.8 Test de JarqueBera 2.9 Recursos del capítulo 2.10 Apéndice", " Capítulo 2 Quantmod IMPORTATE: Aún no está del todo listo el formato en pdf, por lo que recomiendo verlo online. El paquete quantmod para R esta diseñado para la asistencia quantitativa de los traders en el desarrollo de sus estrategias y modelos financieros. 2.1 ¿Que es quantmod? Un entorno rápido, donde los operadores cuantitativos pueden explorar y construir modelos de negociación rápida y limpiamente. A través de la función getSymbols podemos extraer datos financieros desde varias fuentes: Google Finance, Yahoo Finance, Federal Reserve Bank of St. Louis FRED (más de 11,000 series !!!) y Oanda. Incluso desde fuentes propias: MySQL , R (Rdata) y Comma Separated Value files (csv). No es el paquete definitivo dado que se complementa con otros, tales como: TTR, zoo y xts. En lo que respecta al análisis técnico son las más usadas en el mercado y usan todas las propiedades que hacen al lenguaje R útil para realizar análisis de datos5. 2.2 Obtención de Datos Para comenzar, como todo paquete en R se debe instalar # Instalación package install.packages(&quot;quantmod&quot;) Una vez que esté instalado, creamos nuestro script usando ctrl/cmd + shift + n y lo “llamamos” con # Cargamos &quot;quantmod&quot; library(&quot;quantmod&quot;) HINT: con ctrl + R en windows/Linux y cmd + R en MAC OS agregamos más rapido comentarios (sección) en Rstudio. quantmod provee una función para descargar datos desde fuentes externas. Esta función se llama getSymbols, para mayor información escribir en la linea de comandos ?getSymbols6. Por defecto, se crea un objeto en el workspace (Global Environment) con el nombre del ticker/nemotécnico seleccionado. Imaginemos por un momento que necesitamos analizar el S&amp;P 500 desde el 2010 hasta la fecha con periocidad diaria. Lo primero que debemos hacer es pensar desde que fuente vamos a descargar los datos, como es un índice accionario se recomienda usar yahoo finance, luego buscar el nemotécnico, en este caso es “^GSPC”. getSymbols(&quot;^GSPC&quot;, src = &quot;yahoo&quot;, from = &quot;2010-01-01&quot;, to = &quot;2010-07-30&quot;, periodicity = &quot;daily&quot;) ## [1] &quot;^GSPC&quot; 2.2.1 ¿Qué hizo la función getSymbols? La función getSymbols se construye basicamente de cinco opciones7: El ticker/nemotécnico, eg. ^GSPC. src, que es la abreviación de “source”, eg. yahoo, FRED… from, es el inicio de la fecha a descargar, tener presente que se incluye la fecha en nuestros datos. to, es el final del periodo para los datos, este no se incluye. periodicity, es la periodicidad de los datos, eg. daily, monthly o yearly, solo algunos datos se ajustan a las tres periodicidades. En el ejemplo anterior se descargo desde yahoo los datos del S&amp;P 500 desde Enero del 2010 hasta el viernes 27 de Julio del 2018 con periodicidad diaria, construyendo un objeto en formato xts cuyo nombre es GSPC. 2.3 Graficando con chartSeries Aún no introducimos la librería ggplot2, sin embargo, quantmod también nos permite graficar. 2.3.1 chartSeries Para graficar basta con escribir el nombre del objeto con clase (class) xts, en nuestro caso es GSPC que representa al Standard and Poor 500. Si escribimos TA = NULL, charSeries no mostrará el volume8 chartSeries(GSPC, TA=NULL) Figure 2.1: Gráfico con chartSeries con TA = NULL chartSeries(GSPC, TA=NULL) Figure 2.2: Gráfico con chartSeries sin TA = NULL Pero cuando las series son muy largas, podemos ver tendencias pero dificulta ver cambios importantes a nivel de análisis técnico. chartSeries(GSPC, subset = &quot;last 3 months&quot;) Figure 2.3: Los últimos 3 meses de GSPC Con el código anterior nos enfocamos solo en los tres meses anteriores. 2.4 Graficando con ggplot2 Si bien chartSeries es una alternativa a plot o plotly, este no nos permite realizar gráficos que se adapten a nuestras necesidades. ¿Qué pasa si queremos graficar retornos o retornos acumulados? la opción por exelencia es ggplot2. 2.4.1 Breve introducción a ggplot2 Todo ggplot2 plot tiene tres componentes: Datos Un conjunto de aesthetic mappings entre variables y propiedades de visualización. Al menos una layer que describe la observación, son usualmente creadas con la función geom_* library(ggplot2) A continuación usaremos la base que viene pre cargada con R cuando lo instalamos, que es cars9 ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() Figure 2.4: Ejemplo 1 usando ggplot2 Esto produce el scatterplot definido como: Datos: mpg Aesthetic mapping: tamaño del motor en la posición x, gasolina en la posición y. Layer: puntos. 2.4.2 Color, tamaño, forma y otros atributos del aesthetic Se debe usar otro aesthetics como colour, shape y size (ggplot acepta los nombres americanos como británicos) ggplot(mpg, aes(displ, cty, colour = class)) + geom_point() Figure 2.5: Ejemplo 2 usando ggplot2 Como se puede ver, se creo una guía con los valores, leyenda, así podemos “leer” el gráfico. Si se quiere aesthetic para valores fijos, sin scaling: ggplot(mpg, aes(displ, hwy)) + geom_point(aes(colour = &quot;blue&quot;)) Figure 2.6: Ejemplo 3 usando ggplot2 ggplot(mpg, aes(displ, hwy)) + geom_point(colour = &quot;blue&quot;) Figure 2.7: Ejemplo 3 usando ggplot2 Ejercicios: aes(displ, hwy, colour = class) aes(displ, hwy, shape = drv) aes(displ, hwy, size = cyl) Se recomienda usar colour y shape con variables categóricas. Mientras que size funciona bien con variables continuas. 2.4.3 S&amp;P 500 con ggplot2 gspc &lt;- as.data.frame(GSPC) g1 &lt;- ggplot(gspc) + geom_line(mapping = aes(index(gspc),GSPC.Adjusted)) g1 &lt;- g1 + labs(title = &quot;S&amp;P 500&quot;, subtitle = &quot;Desde Enero 2010 a 2018&quot;) + xlab(&quot;Fecha&quot;) + ylab(&quot;&quot;) g1 &lt;- g1 + theme_bw() g1 Figure 2.8: Standard and Poor 500 usando ggplot2 2.5 Multiples Datos A continuación trabajaremos con las acciones de Oracle, Nvidia, IBM y AMD, comenzamos con crear un objeto con los nombres de los tickers tickers &lt;- c(&quot;ORCL&quot;,&quot;AMD&quot;,&quot;IBM&quot;,&quot;NVDA&quot;) descargamos los datos con las características requeridas, que son las mismas que usamos anteriormente con S&amp;P 500 getSymbols(tickers, src = &quot;yahoo&quot;, from = &quot;2010-01-01&quot;, to = &quot;2018-07-30&quot;, periodicity = &quot;daily&quot;) ## [1] &quot;ORCL&quot; &quot;AMD&quot; &quot;IBM&quot; &quot;NVDA&quot; Acá deben tener mucha atención: list &lt;- lapply(tickers, function(x) Cl(get(x))) precio.cierre &lt;- do.call(merge,list) 2.5.1 Retornos La formula para calcular (log) retornos es \\[ r_t = log(1 + R_t) = log(\\frac{P_t}{P_{t-1}}) = p_t - p_{t-1} \\] donde \\(p_t = log(P_t)\\) es llamado “log price”. Ahora pasamos a construir el retorno. retornos &lt;- data.frame(apply(precio.cierre, 2, function(x) Delt(x, type = &quot;log&quot;)), fecha = index(precio.cierre)) %&gt;% rename(orcl = ORCL.Close, amd = AMD.Close, ibm = IBM.Close, nvda = NVDA.Close) %&gt;% na.omit() 2.5.2 Retornos Acumulados Si graficamos los retornos no será muy descriptivo, una forma es trabajar con su acumulado. Con la misma lógica usamos la función cumsum(). acumulados &lt;- data.frame(apply(retornos[1:4], 2, function(x) cumsum(x)), fecha = index(precio.cierre[-1])) 2.5.2.1 Gráfico retornos acumulados library(&quot;reshape2&quot;) reshape &lt;- melt(acumulados, id.vars = &quot;fecha&quot;) g2 &lt;- ggplot(reshape) + geom_line(mapping = aes(fecha,value, color = variable)) g2 &lt;- g2 + labs(title = &quot;Retornos Acumulados&quot;, subtitle = &quot;Oracle, AMD, IBM y Nvidia&quot;) g2 &lt;- g2 + theme_bw() + xlab(&quot;Fecha&quot;) + ylab(&quot;Retornos Acumulados&quot;) g2 &lt;- g2 + scale_color_manual(&quot;Tickers&quot;, values = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;orange&quot;)) g2 &lt;- g2 + theme(legend.position = &quot;bottom&quot;) g2 Figure 2.9: Retornos Acumulados de los tickers 2.6 Estadística Descriptiva Existe muchas formas de obtener la estadística descriptiva en R, un librería es fBasics, la que a su vez contiene test de normalidad. library(&quot;fBasics&quot;) summary &lt;- basicStats(retornos[1:4])[c(&quot;Mean&quot;, &quot;Stdev&quot;, &quot;Median&quot;, &quot;Minimum&quot;, &quot;Variance&quot;, &quot;Maximum&quot;, &quot;nobs&quot;,&quot;Skewness&quot;,&quot;Kurtosis&quot;),] 2.7 Ratio de Sharpe EL ratio de Sharpe es una medida de desempeño para portafolios, el que se define como \\[ SR = \\frac{E(R_i) - r_f}{\\sigma_i} \\] Donde \\(E(R_i) = \\mu_i\\) es el retorno del portafolio \\(i\\), \\(r_f\\) la tasa libre de riesgo y \\(\\sigma_i\\) la desviaciòn estandar del portafolio \\(i\\). Si asumimos como ejercicio que no diversificamos y “construimos” cuatro portafolios con el 100% es invertido en cada uno de los activos. Para realizar el cálculo del ratio de Sharpe (SR) para Oracle SR_orcl &lt;- (mean(retornos$orcl) - 0.0000 )/sd(retornos$orcl) con mean(retornos$orcl) vamos a obtener el promedio de la primera columna del objeto retornos que es Oracle (en el data.frame la columna se llama orcl, si tuviese otro nombre como por ejemplo perrito, entonces hubiese sido mean(retornos$perrito)), si quisieramos AMD debería ser amd y asì sucesivamente. El 0.0000 sería la tasa libre de riesgo que la asumimos mensual y sd(retornos[1]) nos calcula la desviación estandar. Dado que poseemos 4 activos con sus respectivos retornos, deberiamos construir cuatro objetos que partan con SR. 2.8 Test de JarqueBera El test de jarque-bera usa los coeficientes de la skewness y kurtosis de la muestra y se usa para testar normalidad. Otros test comunes son el de Anderson–Darling, Cramér–von Mises, y Kolmogorov–Smirnov. En resumen compara que la skewness sea 0 y la kurtosis sea 3 bajo normalidad. \\[ JB = n{\\widehat{Sk}^2 /6 + (\\widehat{KUr} - 3)^2 /24} \\] El test se encuentra en varias librerías, una de ellas es fBasics que deberíamos tener instalada y cargada. Para obtener los resultados del test para Oracle jarqueberaTest(retornos$orcl) Para los demàs activos hay que solo cambiar por el nombre de la columna correspondiente. 2.9 Recursos del capítulo Presentación 2.10 Apéndice Existe más de una forma de calcular los retornos y retornos acumulados. A continuación cargaremos una base que contiene los precios al cierre desde Enero del 2013 hasta Diciembre del 2018 con periodicidad mensual de las siguientes empresas tecnológicas: Facebook (FB) Amazon (AMZN) Apple (AAPL) Netflix (NFLX) Google (GOOG) Ahora en adelante FAANG. La base de datos se encuentran almacenada en Dropbox en el siguiente enlace https://www.dropbox.com/s/tjqvs9w16al1jl2/FAANG.csv?dl=1 Como tiene una extensión csv, utilizamos: FAANG &lt;- read_csv(&quot;https://www.dropbox.com/s/tjqvs9w16al1jl2/FAANG.csv?dl=1&quot;) De esta manera podemos descargarla inmediatamente desde dropbox a nuestra sesión en RStudio. La base de FAANG contiene las siguientes observaciones. 2.10.1 Retorno y retorno acumulado La forma en que calcularemos el retorno logarítmico es siguiendo la formula presentado durante el capítulo: \\[ r_t = log(1 + R_t) = log(\\frac{P_t}{P_{t-1}}) = p_t - p_{t-1} \\] Como tenemos la fecha (date) y el resto de las columnas con los precios, una forma es crear una objeto con tres columnas, fecha (date), symbol (tickers) y precios (prices). Lo anterior se logra utilizando gather(symbol, prices, -date), luego agrupamos por symbol por medio de group_by(symbol) y creamos el retorno mutate(returns = log(prices/lag(prices))). Como tendremos NA usamos filter(!is.na(returns)), finalmente eliminamos la columna price y extendemos el objeto de tal forma de tener la fecha (date) y las columnas restantes sea el retorno correspondiente a cada tickers (symbol), spread(symbol, returns). Todo lo anterior se resume en el siguiente código: # retornos FAANG_returns &lt;- FAANG %&gt;% gather(symbol, prices, -date) %&gt;% # en la tarea es -Date y no -date group_by(symbol) %&gt;% mutate(returns = log(prices/lag(prices))) %&gt;% filter(!is.na(returns)) %&gt;% select(-prices) %&gt;% spread(symbol, returns) La lógica para los retornos acumulados es el mismo, pero ahora no debemos trabajar con el objeto FAANG, sino con FAANG_returns. FAANG_acum &lt;- FAANG_returns %&gt;% gather(symbol, returns, -date) %&gt;% group_by(symbol) %&gt;% mutate(returns_acum = cumsum(returns)) %&gt;% select(-returns) %&gt;% spread(symbol, returns_acum) 2.10.2 Graficar retorno acumulado FAANG_acum %&gt;% gather(symbol, returns_acum, -date) %&gt;% ggplot(aes(y = returns_acum, x = date, color = symbol)) + geom_line(size = 1.5) + labs(title = &quot;Retornos Acumulados&quot;, subtitle = &quot;FAANG&quot;, color = &quot;&quot;) + theme_bw() + theme(legend.position = &quot;bottom&quot;, legend.direction = &quot;horizontal&quot;) Proximamente incluire el tidyquant↩ No solo funcióna con getSymbols, si no que con todas las funciones de distintas librerias, basta con ante poner ? y luego el nombre la función↩ Por el momento solo trabajaremos con estas opciones, exiten más.↩ TA proviene de Technical Analysis↩ Esta base es muy común en los software estadísticos y presenta datos de autos.↩ "],
["portafolio.html", "Capítulo 3 Introducción a teoría de portafolio 3.1 Librería IntroCompFinR 3.2 Cargando la librería y la base de datos", " Capítulo 3 Introducción a teoría de portafolio IMPORTANTE: Aún no está del todo listo el formato en pdf, por lo que recomiendo verlo online. 3.1 Librería IntroCompFinR Para la teoría de portfolio vamos a utilzar la librería IntroCompFinR (Intro to Computational Finance in R) creado por el profesor Eric Zivot. Debemos instalar primero las librerías que utiliza IntroCompFinR: if(!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) p_load(&quot;PerformanceAnalytics&quot;,&quot;quadprog&quot;,&quot;xts&quot;) Ya instaladas las dependencias, descargamos IntroCompFinR : install.packages(&quot;IntroCompFinR&quot;, repos=&quot;http://R-Forge.R-project.org&quot;) 3.1.1 Funciones útiles de IntroCompFinR Funciones Descripciones getPortfolio Crea un portafolio (objeto) globalMin.portfolio Computa el portafolio de mímina varianza efficient.portfolio Computa el portafolio de mímina varianza sujeto a un retorno tangency.portfolio Computa el portafolio tangente efficient.frontier Computa la frontera eficiente 3.2 Cargando la librería y la base de datos Una vez la instalada la librería, procedemos a cargarla en conjunto con aquellas que utilizaremos en esta ayudantía: if(!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) p_load(&quot;IntroCompFinR&quot;,&quot;readxl&quot;,&quot;tidyverse&quot;) Como ya está cargado readxl cargamos el archivo stocks.xlsx, que ya posee los retornos10. # acá están los retornos ya calculados, para replicarlos vean el apunte stocks &lt;- read_xlsx(&quot;datasets/stocks.xlsx&quot;) Considerando tres activos riesgosos (Starbucks, Nordstrom y Microsoft), definimos un vector columna \\(3x1\\) el que tendrá los retornos y los pesos: \\[ \\mathbf{R} = \\begin{pmatrix} R_{a} \\\\ R_{b} \\\\ R_{c} \\end{pmatrix} , \\mathbf{x} = \\begin{pmatrix} x_{a} \\\\ x_{b} \\\\ x_{c} \\end{pmatrix} \\] El vector de retornos esperados es: \\[ E[\\mathbf{R}] = E \\begin{bmatrix} \\begin{pmatrix} R_{a} \\\\ R_{b} \\\\ R_{c} \\end{pmatrix} \\end{bmatrix} = \\begin{pmatrix} E[R_{a}] \\\\ E[R_{b}] \\\\ E[R_{c}] \\end{pmatrix} = \\begin{pmatrix} \\mu_{a} \\\\ \\mu_{b} \\\\ \\mu_{c} \\end{pmatrix} = \\mathbf{\\mu} \\] La matriz \\(3x3\\) de varianza y covarianza de los retornos es: \\[ var[\\mathbf{R}] = \\begin{pmatrix} \\sigma^2_{a} &amp; \\sigma_{ab} &amp; \\sigma_{ac} \\\\ \\sigma_{ab} &amp; \\sigma^2_{b} &amp; \\sigma_{bc} \\\\ \\sigma_{ac} &amp; \\sigma_{bc} &amp; \\sigma^2_{c} \\end{pmatrix} = \\Sigma \\] Notar que la matriz de covarianza es simétrica (\\(\\Sigma = \\Sigma^{&#39;}\\)). Para construir las matrices anteriores en R: # Promedio mean &lt;- apply(stocks[2:4], 2 , function(x) mean(x)) # Desviación Estandar sd &lt;- apply(stocks[2:4], 2 , function(x) sd(x)) # Covarianza cov &lt;- cov(stocks[2:4]) si quieren replicarlo vean los videos↩ "],
["bonos.html", "Capítulo 4 Renta Fija 4.1 Precio de un Bono 4.2 Dos formas de hacer lo mismo 4.3 Funciones 4.4 Relación precio del Bono y Yield 4.5 Trabajando con yields reales 4.6 Duración y Convexidad de un Bono 4.7 Efecto Dolar 4.8 Ejercicio 4.9 Apéndice 4.10 Recursos del capítulo", " Capítulo 4 Renta Fija IMPORTANTE: Aún no está del todo listo el formato en pdf, por lo que recomiendo verlo online. if(!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) p_load(&quot;tidyverse&quot;, &quot;quantmod&quot;) 4.1 Precio de un Bono El precio de un bono se calcula como: \\[ P_{B} = \\sum_{t=1}^{T} \\frac{C}{(1+r)^t} + \\frac{\\text{ValorNominal}}{(1+r)^t} \\] Donde: \\(P_B\\): Precio del Bono \\(C_t\\): Pago interéses o cupones \\(T\\) : Números de períodos o madurez \\(r\\) : Tasa de descuento o yield-to-maturity semi-anual Consideremos el siguiente ejercicio: Calcular el precio de un bono con pago de cupón semestral, Madurez 25 años, Tasa cupón 6.5%, Yield semi-anual de 6.9% y Valor nominal de 100. Para desarrollar el ejercicio, debemos construir por “parte”&quot; los componentes de nuestro bono. Construimos tanto la tasa cupón como la Yield semi-anual. tc &lt;- 0.065 y &lt;- 0.069 Construimos un vector con los valores de los cupones más el principal pago &lt;- c(rep(tc*100/2,49),(100 + tc*100/2)) tanto tc, r y pago se encontraran en Values del global environment, en tipo numeric. c es una función generica para crear vectores, rep hace una repetición de tc*100/2 49 veces y el numero 50, es igual al principal más tc*100/2. Recordar que como es semi-anual se divide por 2 el valor nominal de 100. Para poder trabajar con nuestra base de datos, transformamos nuestro vector pago que está en forma numeric a data frame. pago &lt;- as.data.frame(pago) Ahora existe un objeto con una estructura de datos data frame en nuestro global environment. Nuestro nuevo objeto pago se podría haber llamado de cualquier forma. 4.2 Dos formas de hacer lo mismo Ya construido nuestro objeto pago veremos que en R existen muchas formas de hacer lo mismo: Al principio del capítulo cargamos la libreria tidyverse, está nos permitirá trabajar con un “megapaquete” que incluye otros paquetes en su interior (ggplot2, dplyr, magittr, entre otros). Todos los paquetes que conforman “el Tidyverse” comparten la misma visión sobre el trabajo con datos y la escritura de código. Si vamos a la pestaña packages y escribimos dplyr veremos que está activo, pero nunca lo “llamamos”, esto se debe a tidyverse lo hizo por nosotros. pago1 &lt;- pago %&gt;% mutate(t1 = as.numeric(index(pago)),factor_desc = 1/(1+y/2)^(t1), val_present = pago*factor_desc) %&gt;% summarise(sum(val_present)) %&gt;% rename(`Precio Bono` = `sum(val_present)`) pago1 ## Precio Bono ## 1 95.27 El precio del bono es 95.2663. La otra forma es: # replicamos el objeto pago2 &lt;- pago pago2$t2 &lt;- as.numeric(rownames(pago2)) # Calculamos el factor de descuento pago2$factor_desc &lt;- 1 / (1 + y/2)^(pago2$t2) # Calculamos el valor presente pago2$val_present &lt;- pago2$factor_desc*pago2$pago # Calculamos el precio sum(pago2$val_present) ## [1] 95.27 Como es de esperarse obtenemos el mismo precio del bono, 95.2663. 4.3 Funciones Dominar por completo las funciones en R lleva practica y dedicación, no obstante, la dificultad que utilizaremos en este capítulo es baja y es un buen ejemplo practico para comenzar. Toda función en R, tiene tres partes. El body(), el código dentro de la función. El formals(), la lista de argumentos que controlan como puedes llamar la función. El environment(), el “mapa” de la locación de las variables de la función. A continuación vamos a crear un función que permita calcular el cuadrado de cualquier número: f &lt;- function(x){ x^2 } Para obtener el cuadrado de 2 y de 4: f(2) ## [1] 4 f(4) ## [1] 16 En el ejemplo anterior el formals() de f: formals(f) ## $x el body() de f: body(f) ## { ## x^2 ## } y el environment() de f: environment(f) ## &lt;environment: R_GlobalEnv&gt; Ya visto una breve introducción a funciones en R, procedemos a construir una función que nos permitirá valorizar cualquier bono que pague cupones iguales: # p: valor nominal; tc: tasa cupón; t: madurez; y: yield to maturity precio.bono &lt;- function(p,tc,t,y){ pago &lt;- c(rep(tc*p, t - 1),p*(1 + tc)) pago &lt;- as.data.frame(pago) pago$t &lt;- as.numeric(rownames(pago)) pago$factor_desc &lt;- 1 / (1 + y)^(pago$t) pago$valor_prese &lt;- pago$factor_desc*pago$pago sum(pago$valor_prese) } precio.bono(100,0.065/2,50,0.069/2) ## [1] 95.27 Usando el mismo ejemplo de la sección anterior, obtenermos un precio igual a 95.2663. 4.4 Relación precio del Bono y Yield 4.4.1 Valorización Ahora utilizando la función precio.bono valorizaremos un bono con las siguientes características: Principal : 100 Tasa Cupón: 5% Madurez: 10 años Yield: 4.29% # Valoramos el siguiente Bono precio.bono(p = 100, tc = 0.05, t = 10, y = 0.0429) ## [1] 105.7 4.4.2 Construcción yields Se contruirá una secuencia de yields: # Cosntruimos yields yields &lt;- seq(0.02, 0.4, 0.01) La función seq generá una secuencia. En este caso parte del 0.02 hasta el 0.4 pero con intervalos de 0.01. # Convertimos yields a data frame como antes yields &lt;- as.data.frame(yields) 4.4.3 Loops # Calaculamos el precio del bono para distintas yields for (i in 1:nrow(yields)) { yields$precio[i] &lt;- precio.bono(100, 0.10, 20, yields$yields[i]) } 4.4.4 Graficando Una manera de visualizar datos es usar ggplot2, se recomienda que añadan por parte lo que desean en su gráfico. # Graficamos con ggplot2 g1 &lt;- ggplot(data = yields,aes(x = yields*100, y = precio)) + geom_line(size = 1.5, color = &quot;red&quot;) g1 &lt;- g1 + geom_point(size = 3, color = &quot;red&quot;) g1 &lt;- g1 + ggtitle(&quot;Relación inversa:&quot;, subtitle = &quot;Precio del Bono vs Yield&quot;) g1 &lt;- g1 + xlab(&quot;Yield (%)&quot;) + ylab(&quot;Precio del bono&quot;) g1 &lt;- g1 + geom_ribbon(aes(ymin = 0, ymax = pmax(precio,0)), fill=&quot;pink&quot;, col=&quot;red&quot;, alpha=0.5) g1 &lt;- g1 + theme_bw() g1 &lt;- g1 + theme(panel.border = element_rect(colour = &quot;black&quot;, fill = NA, size = .5), panel.grid.major = element_line(colour = &quot;#d3d3d3&quot;)) g1 Figure 4.1: Relación Bono vs Yield # Guarmados gráfico ggsave(&quot;retorno-yield.png&quot;,width = 8.5, height = 4.5, dpi = 300) 4.5 Trabajando con yields reales quantmod es uno de las librerías más ocupadas en R para extraer datos financieros, te permite graficar, realizar análisis técnico, calcular retornos (Delt(x)), etc. Aunque las series son descargadas con estructura xts, la podemos transformar a data frame. A continuación descargaremos la yield de los bonos del tesoro de Estados Unidos a 10 años: t10yr &lt;- getSymbols(Symbols = &quot;DGS10&quot;, src = &quot;FRED&quot;, auto.assign = FALSE) t10yr &lt;- subset(t10yr[&quot;2000-01-01/2018-04-17&quot;]) Con la función subset extramos una parte de los datos, especificamente desde 2000-01-01 hasta 2018-04-17. Luego graficamos usando la función chartSeries de quantmod. Tener cuidado con la función, dado que solo funciona con extensión xts. # Grafico con chartSeries de quantmod solo funciona con xts chartSeries(t10yr, theme = &quot;white&quot;) Figure 4.2: yield del tesoro de los Estados Unidos con chartSeries En caso que se quiera graficar usando ggplot2: t10yr.df &lt;- as.data.frame(t10yr) t10yr.df &lt;- t10yr.df %&gt;% mutate(fecha = as.Date(rownames(t10yr.df))) %&gt;% na.omit() g3 &lt;- ggplot(data = t10yr.df,aes(x = fecha , y = DGS10)) + geom_line(size = 1, color = &quot;green&quot;) g3 &lt;- g3 + ggtitle(&quot;10-Year US Treasury Yields&quot;, subtitle = &quot;Desde 2000-01-01 hasta 2018-04-17&quot;) g3 &lt;- g3 + ylab(&quot;Fecha&quot;) +xlab(&quot;Yield(%)&quot;) g3 &lt;- g3 + theme_bw() + theme(panel.border = element_rect(colour = &quot;black&quot;, fill = NA, size = .5), panel.grid.major = element_line(colour = &quot;#d3d3d3&quot;)) g3 Figure 4.3: yield del tesoro de los Estados Unidos con ggplot2 # Guarmados gráfico ggsave(&quot;treasury-yields.png&quot;,width = 8.5, height = 4.5, dpi = 300) 4.6 Duración y Convexidad de un Bono 4.6.1 Extración de la yield La función subset permite extraer una parte de tu base según un criterio como vimos con anterioridad. En el código presentado a continuación, extraemos un valor de la yield para una fecha en especifico, 2017-03-03 y luego la dividimos por 100. # Extraemos un valor en específico t10yr_yield &lt;- t10yr.df %&gt;% subset(fecha == &quot;2017-03-03&quot;) t10yr_yield &lt;- as.numeric(t10yr_yield$DGS10)*0.01 4.6.2 Duración (Bono Bullet o Americano) Existen dos Duraciones, la de Macaulay y modificada (o de Hicks), las que miden sensibilidad del precio ante cambios de la yield. Dos bonos con la misma duración tendrá el mismo cambio en precio estimado. Macaulay: \\[ \\text{Duracion de Macaulay} =\\bigg[ \\frac{1 + y}{y} - \\frac{1+y + [n \\cdot (c - y)]}{[ c\\cdot((1+y)^n - 1)]+y} \\bigg] \\] Modificada: \\[ \\text{Duracion Modificada} = \\text{Duracion de Macaulay}/(1+y) \\] Aproximación Duración Modificada: \\[ Aprox.Dur.Mod.= \\frac{MV_{-}-MV_{+}}{2 \\cdot \\Delta y \\cdot MV_{0}} \\] 4.6.2.1 Duración Macaulay Como ya presentamos la formula de la duración de Macaulay, la construimos como una función. # duracion de Macaulay macaulay &lt;- function(y,n,c,t,T){ mac &lt;- (1 + y)/y - (1+y+(n*(c-y)))/(c*((1+y)^n -1) + y) print(mac) } Usandola con la yield extraida: macaulay &lt;- macaulay(t10yr_yield,10,0.03) ## [1] 8.817 4.6.2.2 Duración Modificada La aplicación de la duración modificada es directa. # duración modificada modificada &lt;- macaulay/(1+t10yr_yield) modificada ## [1] 8.603 4.6.2.3 Aproximación Duración Modificada Una aproximación a la duración Modificada se puede obtener como: # Para la aproximación de la duración modificada precio.arriba &lt;- precio.bono(p = 100, tc = 0.03, t = 10, y = t10yr_yield + 0.01) precio &lt;- precio.bono(p = 100, tc = 0.03, t = 10, y = t10yr_yield) precio.abajo &lt;- precio.bono(p = 100, tc = 0.03, t = 10, y = t10yr_yield - 0.01) Uniendo los objetos creados. # Calculo de aproximación duración modificada aprox.dur.mod &lt;- (precio.abajo - precio.arriba)/(2 * precio * 0.01) aprox.dur.mod ## [1] 8.62 Así obtenemos una diferencia de 0.0169. 4.6.3 Duración con librería Una librería útil para calcular las duraciones como la convexidad (en la siguiente secciòn) es derivmkts. Si no estamos usando la librería pacman recordar: install.packages(&quot;derivmkts&quot;) library(&quot;derivmkts&quot;) # Con librerias p_load(&quot;derivmkts&quot;) # Duración moficada duration(precio, 3, 10, 100, 1, modified = TRUE) ## [1] 8.603 # Duración Macaulay duration(precio, 3, 10, 100, 1, modified = FALSE) ## [1] 8.817 Si escribimos modified = TRUE, la función duration computa la duración modificada, por otro lado, si modified = FALSE obtenemos la duración de Macaulay. Losa valores son los mismo obtenidos sin librería. 4.6.4 Convexidad La convexidad es la segunda derivada de la curva de rendimiento y es màs precisa que la duración cuando el cambio de la yield es màs “grande”. Esto es porque la duración es la línea tangente en el punto calculado de la curva de rendimientos, el problema es que a medida que nos alejamos por la curva de rendimientos la distancia entre la curva y esa línea calculada se vuelve cada vez más grande. \\[ \\text{Convexidad} = \\frac{1}{P \\times (1+y)^2} \\sum_{t=1}^{T} \\bigg[ \\frac{CF_{t}}{(1 + y)^t } (t^2 + t) \\bigg] \\] Donde: \\(P\\) : Precio Bono. \\(y\\) : yield to maturity. \\(T\\) : Madurez en años. \\(CF_{t}\\) : Cash flow en el tiempo \\(t\\). # Calculamos medida de convexidad convexidad &lt;- (precio.arriba + precio.abajo - 2 * precio)/(precio * (0.01)^2) convexidad ## [1] 88.45 4.6.4.1 Aproximación Convexidad La aproximación a la convexidad se puede obtener usando: \\[ \\text{Aproximacion Convexidad} = \\frac{MV_{-}+MV_{+}-2*MV_{0}}{MV_{0}*\\Delta y^2} \\] donde: \\(MV_{0}\\) : Precio del Bono. \\(MV_{-}\\) : Precio del Bono cuando la tasa de interes aumenta. \\(MV_{+}\\) : Precio del Bono cuando la tasa de interes disminuye. \\(\\Delta y\\) : Cambio en la tasa de interes. 4.6.5 Convexidad con librería: La función convexity de la librería derivmkts permite calcular la convexidad. convexity(precio, 3, 10, 100, 1) ## [1] 88.34 4.7 Efecto Dolar El efecto dolar no es más que la suma del cambio (dollar change) del precio del bono ante un cambio marginal de la yield, tanto para la duración como la convexidad. \\[ \\text{Efecto Dolar} = \\Delta P_{duration} + \\Delta P_{convexity} \\] Donde: \\[ \\text{Duration Dollar Change} = -D \\times \\Delta y \\times P = \\Delta P_{duration} \\] Donde: \\(D\\) : Duración. \\(\\Delta y\\) : Cambio en la yield. \\(P\\) : Precio Bono. \\[ \\text{Convexity Dollar Change} = 0.5 \\times C \\times (\\Delta y)^2 \\times P = \\Delta P_{convexity} \\] Donde: \\(C\\) : Convexidad. \\((\\Delta y)^2\\) : Cambio en la yield al cuadrado. \\(P\\) : Precio Bono. 4.8 Ejercicio Duración y Convexidad Un portfolio manager de renta fija nacional ha invertido en un bono a cuatro años de ENERSIS. El instrumento cuenta con una tasa cupón anual de 3 % y un valor nominal de US $100 millones. Adicionalmente sabe que actualmente la tasa de descuento TIR anual es del 8 %. Debido a un aumento en el nivel de precios, el portfolio manager se encuentra preocupado por un eventual incremento en la tasa de interés que fija el Banco Central, por lo tanto recurre a Ud. para que lo asesore ante este posible escenario de alza de tasas. Calcule la duración y convexidad de este bono. Calculamos el precio del bono: precio &lt;- precio.bono(p = 100, tc = 0.03, t = 4, y = 0.08) La duración es: duration_mac &lt;- duration(precio, 3, 4, 100, 1, modified = FALSE) duration_mac ## [1] 3.81 duration_mod &lt;- duration(precio, 3, 4, 100, 1, modified = TRUE) duration_mod ## [1] 3.528 La convexidad es: convexity &lt;- convexity(precio, 3, 4, 100, 1) Utilizando la duración, calcule cuánto bajará de precio el bono ante un aumento de la TIR del 1 % y ante un aumento del 10%. Cómo cambia el resultado anterior si se utiliza convexidad. Si la variación es de 1 %, la regla de la duración entrega los siguientes resultados: -duration_mod*0.01 ## [1] -0.03528 Si la variación es de 1 %, la regla de la convexidad entrega los siguientes resultados: -duration_mod*0.01 + 0.5*convexity*(0.01)^2 ## [1] -0.03447 Se observa que para variaciones pequeñas ambas medidas entregan resultados muy similares Por otro lado, si la variación en la TIR es de 10 % la regla de duración arroja los siguientes resultados: -duration_mod*0.1 ## [1] -0.3528 Mientras que para la convexidad se tiene lo siguiente: -duration_mod*0.1 + 0.5*convexity*(0.1)^2 ## [1] -0.2724 Donde se observa que los resultados guardan una diferencia mucho mayor cuando se examina el efecto en el precio de una variación significativa en la tasa de interés 4.9 Apéndice 4.9.1 Bono Frances El precio del Bono Frances es dístinto al Bono Bullet, dado que amortiza mediante una renta constante de \\(n\\) cuotas. \\[ cuota = C_{0} \\times \\frac{i \\times (1+i)^{n}}{(1+i)^{n}-1} \\] donde: \\(C_{0}\\) = Principañ \\(n\\) = Duración de la operación en meses, trimestres, semestres o años. \\(i\\) = Tasa de interés. En R la función sería: precio_frances &lt;- function(p,tc,t,y){ cuota &lt;- p*(tc*(1+tc)^(t))/((1+tc)^(t) - 1) pago &lt;- c(rep(cuota, t)) pago &lt;- as.data.frame(pago) pago$t &lt;- as.numeric(rownames(pago)) pago$factor_desc &lt;- 1 / (1 + y)^(pago$t) pago$valor_prese &lt;- pago$factor_desc*pago$pago sum(pago$valor_prese) } Para calcular la duración y convexidad cambia y no podemos usar la formula mostrada con anterioridad: Duración Bono Frances: \\[ D = \\frac{\\sum_{t=1}^{n} C_{t} t (1+r)^{-t}}{\\sum_{t=1}^{n} C_{t} (1+r)^{-t}} \\] duracion_frances &lt;- function(p,tc,t,y){ cuota &lt;- p*(tc*(1+tc)^(t))/((1+tc)^(t) - 1) pago &lt;- c(rep(cuota, t)) pago &lt;- as.data.frame(pago) pago$t &lt;- as.numeric(rownames(pago)) pago$arriba &lt;- pago$pago*pago$t*(1+y)^{-pago$t} pago$abajo &lt;- pago$pago*(1+y)^{-pago$t} duracion &lt;- sum(pago$arriba)/sum(pago$abajo) print(duracion) } Convexidad Bono Frances: convexidad_frances &lt;- function(p,tc,t,y,precio){ # rep returns a vector with value = p * r and times = ttm -1 cuota &lt;- p*(tc*(1+tc)^(t))/((1+tc)^(t) - 1) pago &lt;- c(rep(cuota, t)) pago &lt;- as.data.frame(pago) pago$t &lt;- as.numeric(rownames(pago)) pago$factor_desc &lt;- 1 / (1 + y)^(pago$t) pago$valor_prese &lt;- pago$factor_desc*pago$pago*((pago$t)^2 + pago$t) print(sum(pago$valor_prese)*(1/(precio*(1+y)^2))) } 4.10 Recursos del capítulo "],
["options.html", "Capítulo 5 Opciones, Derivados y Futuros 5.1 Call &amp; Put 5.2 Estrategias 5.3 Black &amp; Scholes 5.4 Black &amp; Scholes con Datos Reales 5.5 Árbol Binomial", " Capítulo 5 Opciones, Derivados y Futuros IMPORTANTE: Aún no está del todo listo el formato en pdf, por lo que recomiendo verlo online. if(!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) p_load(&quot;tidyverse&quot;,&quot;quantmod&quot;) 5.1 Call &amp; Put A modo de resumen, existen cuatro tipos de posiciones en las opciones: Posición larga en una opción de compra (call) Posición larga en una opción de venta (put) Posición corta en una opción de compra (call) Posición corta en una opción de venta (put) Simulamos nuestro \\(S_t\\): # Valores para el ejemplo s &lt;- seq(0,130,by=10) # Precio Para la call usamos: v (precio de la call) = $5, precio de ejercicio (k) = 100. Para la put usamos: v (precio de la put) = $7, precio de ejercicio (k) = 70. 5.1.1 Posición Larga en Call: Payoff &amp; Profit EL rendimiento proveniente de una opción larga en una opción de compra europea es: Payoff opción call larga \\[ \\text{payoff} = \\text{max}(S_t - k,0) \\] Profit opción call larga \\[ \\text{profit} = \\text{payoff} - v*e^{-r*t} \\] Construimos la función: long.callpayoff &lt;- function(s,k,v,r,t){ data.frame(&quot;payoff&quot; = pmax(0,s-k), &quot;periodo&quot; = s) %&gt;% mutate(&quot;profit&quot; = payoff - v*exp(-r*t)) } payoff.longcall &lt;- long.callpayoff(s,100,5,0,0) Gráfico posición larga en call: g1 &lt;- ggplot(payoff.longcall) + geom_line(aes(x = periodo, y = payoff), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Payoff&quot;) g1 &lt;- g1 + theme_bw() + ggtitle(&quot;Payoff de una Option Call&quot;) g1 &lt;- g1 + labs(subtitle = &quot;Posicion Larga en Call&quot;) g1 &lt;- g1 + scale_x_continuous(limits=c(70, 130)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) g1 Para corroborar el gráfico ver la figura 9.1 (capítulo 9) del libro Introducción a los Mercados de Futuros y Opciones (octava edición). Para efecto de académicos restringimos la escala del eje x e y (dimensión). Gráfico profit posición larga en call: g2 &lt;- ggplot(payoff.longcall) + geom_line(aes(x = periodo, y = profit), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Profit&quot;) g2 &lt;- g2 + theme_bw() + ggtitle(&quot;Profit de una Option Call&quot;) + labs(subtitle = &quot;Posicion Larga en Call&quot;) g2 &lt;- g2 + geom_hline(yintercept=0, linetype=&quot;dashed&quot;,color = &quot;blue&quot;, size=1.5) g2 &lt;- g2 + scale_x_continuous(breaks = round(seq(min(payoff.longcall$periodo), max(payoff.longcall$periodo), by = 10),1),limits=c(70, 130)) + scale_y_continuous(breaks = round(seq(min(payoff.longcall$profit), max(payoff.longcall$profit), by = 10),1),limits = c(limits=c(-5, 30))) g2 &lt;- g2 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) g2 5.1.2 Posición larga en put: Payoff &amp; Profit EL rendimiento para el tenedor de una opción larga en una opción de venta europea: Payoff opción put larga: \\[ \\text{payoff} = \\text{max}(k - S_t,0) \\] Profit opción put larga: \\[ \\text{profit} = \\text{payoff} - v*e^{-r*t} \\] Construimos la función: long.putpayoff &lt;- function(s,k,v,r,t){ data.frame(&quot;payoff&quot; = pmax(k-s,0), &quot;periodo&quot; = s) %&gt;% mutate(&quot;profit&quot; = payoff - v*exp(-r*t)) } payoff.longput &lt;- long.putpayoff(s,70,7,0,0) Gráfico posición larga en put g3 &lt;- ggplot(payoff.longput) + geom_line(aes(x = periodo, y = payoff), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Payoff&quot;) g3 &lt;- g3 + theme_bw() + ggtitle(&quot;Payoff de una Option Put&quot;) + labs(subtitle = &quot;Posicion Larga en Put&quot;) g3 &lt;- g3 + scale_x_continuous(limits=c(40, 100)) + scale_y_continuous(limits=c(0, 30)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) g3 Para corroborar el gráfico ver la figura 9.2 (capítulo 9) del libro Introducción a los Mercados de Futuros y Opciones (octava edición). Para efecto de académicos restringimos la escala del eje x e y (dimensión). Gráfico posición larga en put: g4 &lt;- ggplot(payoff.longput) + geom_line(aes(x = periodo, y = profit), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Profit&quot;) g4 &lt;- g4 + theme_bw() + ggtitle(&quot;Profit de una Option Put&quot;) + labs(subtitle = &quot;Posicion Larga en Put&quot;) g4 &lt;- g4 + geom_hline(yintercept=0, linetype=&quot;dashed&quot;,color = &quot;blue&quot;, size=1.5) g4 &lt;- g4 + scale_x_continuous(breaks = round(seq(min(payoff.longput$periodo), max(payoff.longput$periodo), by = 10),1),limits=c(40, 100)) + scale_y_continuous(breaks = round(seq(min(payoff.longput$profit), max(payoff.longput$profit), by = 10),1),limits = c(limits=c(-7, 30))) g4 &lt;- g4 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) g4 5.1.3 Posición corta en call: Payoff &amp; Profit EL rendimiento para el tenedor de una posición corta en una opción de compra europea es: Payoff opción call corta: \\[ \\text{payoff} = -\\text{max}(S_t - k,0) = \\text{min}(k - S_t,0) \\] Profit opción call corta: \\[ \\text{profit} = \\text{payoff} + v*e^{-r*t} \\] Construimos la función: short.callpayoff &lt;- function(s,k,v,r,t){ data.frame(&quot;payoff&quot; = pmin(k-s,0),&quot;periodo&quot; = s) %&gt;% mutate(&quot;profit&quot; = payoff + v*exp(-r*t)) } payoff.shortcall &lt;- short.callpayoff(s,100,5,0,0) Gráfico posición corta en call g5 &lt;- ggplot(payoff.shortcall) + geom_line(aes(x = periodo, y = payoff), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Payoff&quot;) g5 &lt;- g5 + theme_bw()+ ggtitle(&quot;Payoff de una Option Call&quot;) + labs(subtitle = &quot;Posicion Corta en Call&quot;) g5 &lt;- g5 + scale_x_continuous(limits=c(70, 130)) + scale_y_continuous(limits=c(-30, 0)) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) g5 Para corroborar el gráfico ver la figura 9.3 (capítulo 9) del libro Introducción a los Mercados de Futuros y Opciones (octava edición). Para efecto de académicos restringimos la escala del eje x e y (dimensión). Gráfico posición corta en call: g6 &lt;- ggplot(payoff.shortcall) + geom_line(aes(x = periodo, y = profit), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Profit&quot;) g6 &lt;- g6 + theme_bw() + ggtitle(&quot;Profit de una Option Call&quot;) + labs(subtitle = &quot;Posicion Corta en Call&quot;) g6 &lt;- g6 + geom_hline(yintercept=0, linetype=&quot;dashed&quot;,color = &quot;blue&quot;, size=1.5) g6 &lt;- g6 + scale_x_continuous(breaks = round(seq(min(payoff.shortcall$periodo), max(payoff.shortcall$periodo), by = 10),1),limits=c(70, 130)) + scale_y_continuous(breaks = round(seq(min(payoff.shortcall$profit), max(payoff.shortcall$profit), by = 10),1),limits = c(limits=c(-30, 5))) g6 &lt;- g6 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) g6 5.1.4 Posición corta en put: Payoff &amp; Profit EL rendimiento para el tenedor de una posición corta en una opción de venta europea es: Payoff opción put corta: \\[ \\text{payoff} = -\\text{max}(k - S_t,0) = \\text{min}(S_t - k,0) \\] Profit opción put corta: \\[ \\text{profit} = \\text{payoff} + v*e^{-r*t} \\] Construimos la función: short.putpayoff &lt;- function(s,k,v,r,t){ data.frame(&quot;payoff&quot; = pmin(s-k,0),&quot;periodo&quot; = s) %&gt;% mutate(&quot;profit&quot; = payoff + v*exp(-r*t)) } payoff.shortput &lt;- short.putpayoff(s,70,7,0,0) Gráfico posición corta en call: g7 &lt;- ggplot(payoff.shortput) + geom_line(aes(x = periodo, y = payoff), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Payoff&quot;) g7 &lt;- g7 + theme_bw() + ggtitle(&quot;Payoff de una Option Put&quot;) + labs(subtitle = &quot;Posicion Corta en Put&quot;) g7 &lt;- g7 + scale_x_continuous(limits=c(40, 100)) + scale_y_continuous(limits=c(-30, 0)) + theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank()) g7 Para corroborar el gráfico ver la figura 9.4 (capítulo 9) del libro Introducción a los Mercados de Futuros y Opciones (octava edición). Para efecto de académicos restringimos la escala del eje x e y (dimensión). g8 &lt;- ggplot(payoff.shortput) + geom_line(aes(x = periodo, y = profit), colour=&quot;red&quot;, size=1.5) + xlab(&quot;Tiempo de Expiracion&quot;) + ylab(&quot;Profit&quot;) g8 &lt;- g8 + theme_bw() + ggtitle(&quot;Profit de una Option Put&quot;) + labs(subtitle = &quot;Posicion Corta en Put&quot;) g8 &lt;- g8 + geom_hline(yintercept=0, linetype=&quot;dashed&quot;,color = &quot;blue&quot;, size=1.5) g8 &lt;- g8 + scale_x_continuous(breaks = round(seq(min(payoff.shortput$periodo), max(payoff.shortput$periodo), by = 10),1),limits=c(40, 100)) + scale_y_continuous(breaks = round(seq(min(payoff.shortput$profit), max(payoff.shortput$profit), by = 10),1),limits = c(limits=c(-30, 7))) g8 &lt;- g8 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) g8 5.2 Estrategias Una estrategia de negociación de diferenciales implica tomar una posición en dos o más opciones del mismo tipo (dos o más opciones de compra o dos o más opciones de venta). Las más conocidas son: Diferenciales Alcistas (bull spreads) Diferenciales bajistas (bear spreads) Estrategias con opciones de tipo mariposa (butterfly spread) Diferenciales Alcistas (bull spreads): Este se crea mediante la adquisición de una opción de compra europea sobre una acción, con cierto precio de ejercicio, y la venta de una opción de compra europea sobre la misma acción con un precio de ejercicio más alto. Ambas opciones tienen la misma fecha de expiración. 5.2.1 Bull Spread Utilidades Intervalo variación precio acción Beneficio derivado de call larga Beneficio derivado de call corta Beneficio total \\(S_t \\leq K_1\\) 0 0 0 \\(K_1 &lt; S_t &lt; K_2\\) \\(S_t - K_1\\) 0 \\(S_t - K_1\\) \\(S_t \\geq K_2\\) \\(S_t - K_1\\) \\(K_2 - S_t\\) \\(K_2 - K_1\\) Ejemplo Bull Spread: Un inversionista adquiere en 3 una opción de compra a tres meses con un precio de ejercicio de 30, y vende en 1 un opción de compra a tres meses con un precio de ejercicio de 35. El beneficio derivado de esta estrategia de diferencial alcista es de 5 si el precio de la acción está por arriba de 35, y de cero si está por debajo de 30. Si el precio de la acción se encuentra entre 30 y 35, el beneficio es la cantidad en la cual el precio de ejercicio excede de 30. El costo de la estrategia es 3 - 1 = 2. Por lo tanto, la utilidad es: Intervalo variación precio acción Utilidad \\(S_t \\leq 30\\) -2 \\(30 &lt; S_t &lt; 35\\) \\(S_t - 32\\) \\(S_t \\geq 35\\) +3 5.2.2 Función Bull Spread Comenzamos contruyendo la estructura de la estrategia: bullspread.call &lt;- function(S,K1,K2,precio1,precio2){ if(K1&gt;=S) stop(&quot;K1 debe ser menor a S.&quot;) if(S&gt;=K2) stop(&quot;K2 debe ser mayor a S.&quot;) #larga callP1 = precio1 #corto callP2 = precio2 stock=unique(round(seq(0,K1,length.out=6))) stock=c(stock,round(seq(K1,K2,length.out=4))) stock=c(stock,round(seq(K2,K2+K1,length.out=6))) stock=unique(stock) payoff=rep(0,length(stock)) profit=rep(0,length(stock)) for(i in 1:length(stock)){ if(stock[i]&lt;=K1) payoff[i]=0 if(stock[i]&gt;=K2) payoff[i]=K2-K1 if(stock[i]&lt;K2 &amp; stock[i]&gt;K1) payoff[i]=stock[i]-K1 profit[i]=payoff[i]+(callP2-callP1) } data &lt;- data.frame(stock,payoff,profit) return(data) } 5.2.3 Posición call Larga &amp; Corta Para el Bull Spread Call Para ilustrar calculamos las dos call (larga y corta): Es la misma función vista anteriormente, solo que en vez de tener una columna llamada “periodo” ahora será “stock”, conceptualmente es lo mismo, pero facilita para graficar: # Posición larga en call long.callpayoff &lt;- function(s,k,v,r,t){ data.frame(&quot;payoff&quot; = pmax(0,s-k), &quot;stock&quot; = s) %&gt;% mutate(&quot;profit&quot; = payoff - v*exp(-r*t)) } # Posición corta en call short.callpayoff &lt;- function(s,k,v,r,t){ data.frame(&quot;payoff&quot; = pmin(k-s,0),&quot;stock&quot; = s) %&gt;% mutate(&quot;profit&quot; = payoff + v*exp(-r*t)) } 5.2.4 Construcción de la Bull Spread Call En el Global Environment vemos el objeto `bull.spread``, que tiene los stock (\\(S_t\\)), payoff y profit. bull.spread &lt;- bullspread.call(32,30,35,3,1) # Extraemos la St s &lt;- bull.spread$stock # Call larga long.call &lt;- long.callpayoff(s,30,3,0,0) # Call corta short.call &lt;- short.callpayoff(s,35,1,0,0) 5.2.5 Gráfico Bull Spread Call g1 &lt;- ggplot(bull.spread[4:10,]) + geom_line(aes(long.call$stock[4:10],long.call$profit[4:10],color = &quot;blue&quot;),linetype=&quot;dashed&quot; ,size=1) g1 &lt;- g1 + geom_line(aes(short.call$stock[4:10],short.call$profit[4:10], color = &quot;red&quot;),linetype=&quot;dashed&quot;,size=1) g1 &lt;- g1 + geom_line(aes(bull.spread$stock[4:10],bull.spread$profit[4:10],color = &quot;green&quot;),size=1) g1 &lt;- g1 + ggtitle(&quot;Estrategia Bull Spreads&quot;) + xlab(&quot;stock&quot;) + ylab(&quot;Profit&quot;) + theme_bw() g1 &lt;- g1 + geom_hline(yintercept=0, linetype=&quot;dashed&quot;,color = &quot;orange&quot;, size=1) g1 &lt;- g1 + scale_color_manual(name = &quot; &quot;,labels = c(&quot;Call larga&quot;, &quot;Bull Spread&quot;, &quot;Call corta&quot;),values = c(&quot;blue&quot;=&quot;blue&quot;,&quot;green&quot;=&quot;green&quot;,&quot;red&quot; = &quot;red&quot;)) g1 &lt;- g1 + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),legend.position=&quot;bottom&quot;) g1 5.2.6 Con librería la Bull Spread Call Una librería útil para construir estratégias es la librería FinancialMath, recuerden install.packages(&quot;FinancialMath&quot;) y luego library(&quot;FinancialMath&quot;): # Con librería # bull.call(S,K1,K2,r,t,price1,price2,plot=FALSE) library(&quot;FinancialMath&quot;) bull.call &lt;- bull.call(31,30,35,0.0000001,3,3,1,plot=TRUE) Otras funciones son, bear.call(),straddle(),strangle(),butterfly.spread(). NB: Es importante que el \\(S_t\\) debe estar entre \\(k_1\\) y \\(k_2\\). Deben incluir una tasa de interés y un T, pero si no se especifica, agreguen una cerca a cero. 5.2.7 Con librería El gráfico Bull Spread Call 5.2.8 Payoff inferior Bull Spread Call de la Librería Los payoff inferiores deberían ser igual a -2: head(bull.call$Payoff,4) Table 5.1: Bull Spread Call Stock Price Payoff Profit 0 0 -2 6 0 -2 12 0 -2 18 0 -2 5.2.9 Payoff superior Bull Spread Call de la Librería Los payoff inferiores deberían ser igual a 3: tail(bull.call$Payoff,4) Table 5.2: Bull Spread Call Stock Price Payoff Profit 11 47 5 3 12 53 5 3 13 59 5 3 14 65 5 3 5.3 Black &amp; Scholes 5.3.1 Black &amp; Scholes: de la formula a una función Las Formulas de Black Scholes y Merton para los precios de las opciones de compra y de venta europeas sobre acciones que no pagan dividendos son: Formulas de Valuación Black,Scholes &amp; Merton \\(c = S_0 N(d_1) - K e^{-rt} N(d_2)\\) \\(p = K e^{-rt} N(-d_2) - S_0 N(-d_1)\\) donde: \\(d_1 = \\frac{ln(S_0/K) + (r + \\sigma^2 / 2)T}{\\sigma \\sqrt{T}}\\) \\ \\(d_2 = \\frac{ln(S_0/K) + (r - \\sigma^2 / 2)T}{\\sigma \\sqrt{T}} = d_1 - \\sigma \\sqrt{T}\\) 5.3.2 Black &amp; Scholes: Ejercicio Uso de la formula en R: El precio de las acciones después de seis meses a partir de la expiración de una opción es de 42, el precio de ejercicio de la opción es de 40, la tasa de interés libre de riesgo es de 10% anual y la volatilidad es de 20% anual. Esto Significa: # Parámetros S0 &lt;- 42 K &lt;- 40 r &lt;- 0.1 T &lt;- 1/2 sigma &lt;- 0.2 5.3.3 Black &amp; Scholes: Función Construimos la función basándonos en la formula: bs.opm &lt;- function(S,K,T,riskfree,sigma,type){ d1&lt;-(log(S/K)+(riskfree+0.5 * sigma^2) * T)/(sigma * sqrt(T)) d2&lt;-d1-sigma * sqrt(T) if(type==&quot;Call&quot;){ opt.val&lt;-S * pnorm(d1)-K * exp(-riskfree * T) * pnorm(d2) } if(type==&quot;Put&quot;){ opt.val&lt;-K * exp(-riskfree * T) * pnorm(-d2)-S * pnorm(-d1) } opt.val } # Para la call C &lt;- bs.opm(S = S0, K = K, T = T, riskfree = r, sigma = sigma, type = &quot;Call&quot; ) C ## [1] 4.759 # Para la put C &lt;- bs.opm(S = S0, K = K, T = T, riskfree = r, sigma = sigma, type = &quot;Put&quot; ) C ## [1] 0.8086 5.3.4 Black &amp; Scholes: Ahora con librerías La librería que se utilizará para usa BS es fOptions, recordar el install.packages(&quot;fOptions&quot;) y posterior library(&quot;fOptions&quot;). library(&quot;fOptions&quot;) La función de la librería es GBSOption(): GBSOption(TypeFlag = &quot; &quot;, S = S0, X = K, Time = T, r = r, b = r, sigma = sigma) En TypeFlag, va “c” para call y “p” para put, tener presente que deberán seleccionar un b que es el annualized cost-of-carry rate, si no se especifica, debe ser igual a r. # Con libreria call GBSOption(TypeFlag = &quot;c&quot;, S = S0, X = K, Time = T, r = r, b = r, sigma = sigma)@price ## [1] 4.759 # Con libreria put GBSOption(TypeFlag = &quot;p&quot;, S = S0, X = K, Time = T, r = r, b = r, sigma = sigma)@price ## [1] 0.8086 5.4 Black &amp; Scholes con Datos Reales 5.4.1 Black &amp; Scholes con Datos Reales: Pasos Una manera de trabajar con datos reales directo usando R, es: Usar las funcion getOptionChain de la librería quantmod. Seleccionar las call y put para la fecha de valuación (recomiendo en objetos separados). Usar la función getSymbols de la librería quantmod para elegir el ticker correspondiente, calcular el retorno y extraer el precio a la fecha que se está haciendo la valuación. “Construimos”&quot; la fecha de expiración y valuación, esto nos permite calcular el \\(T\\) a través de: \\(\\frac{\\text{expiración - valuación}}{365}\\). La tasa libre de riesgo se puede obtener de FRED usando la 3-Month Constant Maturity Treasury yield (debe ser la fecha de valuación, un único valor). Para la volatilidad se puede usar la desviación estándar de los últimos 3 años multiplicado por 252, esto se hace para anualizarlo. Finalmente seleccionamos las que están cerca al at the money y usamos Black &amp; Scholes, por librería o bien la función que creamos. 5.4.2 Parte a Imaginemos que es 31 de mayo del 2018 y queremos valorar las opciones call y put de Oracle con vencimiento al 17 de Agosto del 2018. Para comenzar usamos la función getOptionChain() de la librería quantmod: opciones &lt;- getOptionChain(&quot;ORCL&quot;,Exp=&quot;2021-01-15&quot;) calls &lt;- opciones$calls[,c(1:2,4:6)] # Nos quedamos con las columnas del 1 al 2 y del 4 al 6. puts &lt;- opciones$puts[,c(1:2,4:6)] # Nos quedamos con las columnas del 1 al 2 y del 4 al 6. 5.4.3 Parte b Como debemos obtener el precio de cierre para el 31 de mayo del 2018 y a su vez el histórico de tres años para la volatilidad usamos: # Al 31 de mayo la valuación, 31 de mayo del 2015 fue domingo, por ende, usamos el viernes 29 getSymbols(&quot;ORCL&quot;, from = &quot;2015-05-29&quot;, to = &quot;2018-06-01&quot;, periodicity = &quot;daily&quot;) ## [1] &quot;ORCL&quot; orcl &lt;- as.data.frame(ORCL) %&gt;% # a data.frame mutate(ret = log(ORCL.Adjusted/lag(ORCL.Adjusted))) %&gt;% # construimos el retorno select(ORCL.Adjusted,ret) %&gt;% # Seleccionamos el retorno y precio de ajuste na.omit() # por el NA que se produce del retorno # extraemos el precio a la fecha que nos piden precio &lt;- tail(orcl$ORCL.Adjusted,1) 5.4.4 Parte c y d Con la función getSymbols usamos la fuente de la FRED y extraemos la rf con subset. getSymbols(&quot;DGS3MO&quot;,src =&quot;FRED&quot;, to = &quot;2018-06-01&quot;, periodicity = &quot;daily&quot;) ## [1] &quot;DGS3MO&quot; rf &lt;- as.numeric(subset(DGS3MO[&quot;2018-05-31&quot;]))*0.01 expiracion.date &lt;- as.Date(&quot;2018-08-17&quot;) valuacion.date &lt;- as.Date(&quot;2018-06-01&quot;) TTM &lt;- as.numeric((expiracion.date-valuacion.date)/365) Extraemos del objeto orcl y calculamos su desviación estándar, luego se multiplica por 252. vol.hist &lt;- sd(orcl$ret)*sqrt(252) 5.4.5 Parte e Vemos el precio a la fecha la valuación y seleccionamos aquellas cercana a estar at the money, tanto put como call. bs.call &lt;- calls %&gt;% dplyr::filter(Strike == 45 | Strike == 50) %&gt;% select(Strike,Last,Bid,Ask) bs.put &lt;- puts %&gt;% dplyr::filter(Strike == 45 | Strike == 50) %&gt;% select(Strike,Last,Bid,Ask) # call GBSOption(TypeFlag = &quot;c&quot;, S = precio, X = 45, Time = TTM, r = rf, b = rf, sigma = vol.hist)@price ## [1] 1.145 GBSOption(TypeFlag = &quot;c&quot;, S = precio, X = 50, Time = TTM, r = rf, b = rf, sigma = vol.hist)@price ## [1] 0 # put GBSOption(TypeFlag = &quot;p&quot;, S = precio, X = 45, Time = TTM, r = rf, b = rf, sigma = vol.hist)@price ## [1] 0 GBSOption(TypeFlag = &quot;p&quot;, S = precio, X = 50, Time = TTM, r = rf, b = rf, sigma = vol.hist)@price ## [1] 3.835 5.5 Árbol Binomial Generalización Una generalización cuando queremos realizar un árbol con dos pasos: \\(p = \\frac{e^{r \\Delta t} - d}{u - d}\\) \\(f_u = e^{-r \\Delta t} [pf_{uu} + (1-p) f_{ud}]\\) \\(f_d = e^{-r \\Delta t} [pf_{ud} + (1-p) f_{dd}]\\) \\(f = e^{-r \\Delta t} [pf_{u} + (1-p) f_{d}] = e^{-2r \\Delta t} [p^2 f_{uu} + 2p(1-p) f_{ud} + (1-p)^2 f_{dd}]\\) esto último solo cuando es una opción europea. No obstante, en términos del modelo, \\(u = e^{\\sigma \\sqrt{\\Delta t}}\\) y \\(d = e^{-\\sigma \\sqrt{\\Delta t}} = \\frac{1}{u}\\). 5.5.1 Ejercicio Considere una call europea a dos años con precio de strike de 52 en una acción cuyo precio es 50. Suponga que existen two time steps en un año, y en cada time steps el precio se mueve 30%. La tasa de interes libre de riesgo es 5%. La librería a usar será de nuevo fOptions. library(&quot;fOptions&quot;) 5.5.2 Call europea # Europea CRRTree = BinomialTreeOption(TypeFlag = &quot;ce&quot;, S = 50, X = 52, Time = 2, r = 0.05, b = 0.05, sigma = 0.3, n = 2) CRRTree BinomialTreePlot(CRRTree, dy = 1, cex = 0.8, ylim = c(-6, 7), xlab = &quot;n&quot;, ylab = &quot;valores Opción&quot;) title(main = &quot;Arbol Binomial Opción&quot;) 5.5.3 Call europea gráfico 5.5.4 Call americana # Americana CRRTree.1 = BinomialTreeOption(TypeFlag = &quot;ca&quot;, S = 50, X = 52, Time = 2, r = 0.05, b = 0.05, sigma = 0.3, n = 2) CRRTree.1 BinomialTreePlot(CRRTree.1, dy = 1, cex = 0.8, ylim = c(-6, 7), xlab = &quot;n&quot;, ylab = &quot;valores Opción&quot;) title(main = &quot;Arbol Binomial Opción&quot;) 5.5.5 Call americana gráfico "]
]
